<section id="related-posts-section" class="related-wrapper" style="display:none; margin: 2rem 0; padding: 1.2rem; background: #f8f9fa; border-radius: 10px; border: 1px solid #e0e0e0;">
    <h3 style="margin-top:0; margin-bottom: 0.8rem; font-size: 0.95rem; color: #555; font-weight: 600;">ğŸ’¡ å»¶ä¼¸é–±è®€</h3>
    <div id="related-posts-list" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 0.8rem;"></div>
  </section>
  
  <script>
    document.addEventListener('DOMContentLoaded', async () => {
        const list = document.getElementById('related-posts-list');
        const section = document.getElementById('related-posts-section');
        const currentUrl = window.location.pathname;
        
        // è¦ç¯„åŒ– URL(ç§»é™¤çµå°¾æ–œç·š,çµ±ä¸€æ¯”å°)
        const normalizeUrl = (url) => {
            return url.replace(/\/$/, '').toLowerCase();
        };
        
        const currentNormalizedUrl = normalizeUrl(currentUrl);
        
        console.log("ğŸ“ ç•¶å‰é é¢ URL:", currentUrl);
  
        // åŠ å¼·ç‰ˆï¼šåˆ¤æ–·æ˜¯å¦ç‚ºç•¶å‰é é¢
        const isCurrentPage = (pageUrl) => {
            if (!pageUrl) return false;

            const normPage = normalizeUrl(pageUrl).replace(/\/index\.html?$/, '');
            const normCurrent = normalizeUrl(currentUrl).replace(/\/index\.html?$/, '');

            // æ–¹æ³•1ï¼šè¦ç¯„åŒ–å¾Œå®Œæ•´æ¯”å°
            if (normPage === normCurrent) return true;

            // æ–¹æ³•2ï¼šå–æœ€å¾Œæœ‰æ„ç¾©çš„ segment (slug)
            const getSlug = (path) => {
                const parts = path
                    .replace(/\/index\.html?$/, '')
                    .replace(/\/+$/, '')
                    .split('/')
                    .filter(Boolean);
                
                // å¦‚æœæœ€å¾Œä¸€æ®µæ˜¯æ—¥æœŸæ ¼å¼ï¼Œå¾€å‰å–ä¸€æ®µï¼ˆå¸¸è¦‹ Hugo çµæ§‹ï¼‰
                if (parts.length >= 2 && parts[parts.length-1].match(/^\d{4}(-\d{2}){0,2}$/)) {
                    return parts[parts.length-2] || '';
                }
                return parts[parts.length-1] || '';
            };

            const pageSlug = getSlug(normPage);
            const currSlug = getSlug(normCurrent);

            if (pageSlug && currSlug && pageSlug === currSlug && pageSlug.length > 4) {
                console.log(`[Slug match] è¦–ç‚ºåŒä¸€é : ${pageSlug}`);
                return true;
            }

            return false;
        };

        const toArray = (val) => {
            if (!val) return [];
            if (Array.isArray(val)) return val;
            
            // å¦‚æœæ˜¯å­—ä¸²,å˜—è©¦è§£æ JSON
            if (typeof val === 'string') {
                try {
                    const parsed = JSON.parse(val);
                    if (Array.isArray(parsed)) return parsed;
                    return [parsed];
                } catch (e) {
                    return [val];
                }
            }
            
            return [];
        };
  
        const ai_kw = toArray({{ with .Params.ai_keywords }}{{ . | jsonify }}{{ else }}null{{ end }});
        const categories = toArray({{ with .Params.categories }}{{ . | jsonify }}{{ else }}null{{ end }});
        const tags = toArray({{ with .Params.tags }}{{ . | jsonify }}{{ else }}null{{ end }});
        const projects = toArray({{ with .Params.projects }}{{ . | jsonify }}{{ else }}null{{ end }});
        const clubhouse = toArray({{ with .Params.clubhouse }}{{ . | jsonify }}{{ else }}null{{ end }});
        const series = toArray({{ with .Params.series }}{{ . | jsonify }}{{ else }}null{{ end }});
        const topics = toArray({{ with .Params.topics }}{{ . | jsonify }}{{ else }}null{{ end }});
        const highlights = toArray({{ with .Params.highlights }}{{ . | jsonify }}{{ else }}null{{ end }});
        
        console.log("ğŸ”‘ AI Keywords:", ai_kw);
        console.log("ğŸ“‚ ç•¶å‰è»¸:", { categories, tags, projects, clubhouse, series, topics, highlights });
  
        try {
            if (typeof pagefind === 'undefined') {
                window.pagefind = await import("/pagefind/pagefind.js");
            }
            
            // ğŸ² ç”Ÿæˆéš¨æ©Ÿç¨®å­(åŸºæ–¼ç•¶å‰ URL)
            const generateSeed = (url) => {
                let hash = 0;
                for (let i = 0; i < url.length; i++) {
                    hash = ((hash << 5) - hash) + url.charCodeAt(i);
                    hash = hash & hash;
                }
                return hash;
            };
            
            const seed = generateSeed(currentNormalizedUrl);
            console.log("ğŸ² éš¨æ©Ÿç¨®å­:", seed);
            
            let results = [];
            
            // ğŸ“ æ–¹æ¡ˆ B: å¤šé‡æœå°‹ç­–ç•¥
            console.log("\nğŸ” é–‹å§‹å¤šé‡æœå°‹ç­–ç•¥...");
            
            const allCandidates = new Map(); // ç”¨ Map å»é‡,key æ˜¯ URL
            
            // ğŸ¯ æœå°‹ 1: AI Keywords (20 ç¯‡)
            if (ai_kw.length > 0) {
                console.log("\nğŸ“Œ æœå°‹ 1: AI Keywords");
                try {
                    const search = await window.pagefind.search(ai_kw.join(" "));
                    const data = await Promise.all(search.results.slice(0, 20).map(r => r.data()));
                    
                    console.log(`  âœ… æ‰¾åˆ° ${data.length} ç¯‡`);
                    
                    data.forEach(page => {
                        const normUrl = normalizeUrl(page.url);
                        if (!isCurrentPage(page.url) && !allCandidates.has(normUrl)) {
                            allCandidates.set(normUrl, page);
                        } else if (isCurrentPage(page.url)) {
                            console.log(`ğŸš« æ—©æœŸæ’é™¤è‡ªå·± (AI Keywords): ${page.meta.title} (${page.url})`);
                        }
                    });
                } catch (err) {
                    console.error("  âŒ AI Keywords æœå°‹å¤±æ•—:", err);
                }
            }
            
            // ğŸ¯ æœå°‹ 2: Category (10 ç¯‡)
            if (categories.length > 0) {
                console.log("\nğŸ“Œ æœå°‹ 2: Category");
                try {
                    const search = await window.pagefind.search(categories.join(" "));
                    const data = await Promise.all(search.results.slice(0, 10).map(r => r.data()));
                    
                    console.log(`  âœ… æ‰¾åˆ° ${data.length} ç¯‡`);
                    
                    data.forEach(page => {
                        const normUrl = normalizeUrl(page.url);
                        if (!isCurrentPage(page.url) && !allCandidates.has(normUrl)) {
                            allCandidates.set(normUrl, page);
                        } else if (isCurrentPage(page.url)) {
                            console.log(`ğŸš« æ—©æœŸæ’é™¤è‡ªå·± (Category): ${page.meta.title} (${page.url})`);
                        }
                    });
                } catch (err) {
                    console.error("  âŒ Category æœå°‹å¤±æ•—:", err);
                }
            }
            
            // ğŸ¯ æœå°‹ 3: Projects/Clubhouse/Series (å¦‚æœæœ‰çš„è©±,å„ 5 ç¯‡)
            const axisSearches = [
                { name: 'Projects', terms: projects, limit: 5 },
                { name: 'Clubhouse', terms: clubhouse, limit: 5 },
                { name: 'Series', terms: series, limit: 5 },
                { name: 'Topics', terms: topics, limit: 5 }
            ];
            
            for (const axis of axisSearches) {
                if (axis.terms.length > 0) {
                    console.log(`\nğŸ“Œ æœå°‹: ${axis.name}`);
                    try {
                        const search = await window.pagefind.search(axis.terms.join(" "));
                        const data = await Promise.all(search.results.slice(0, axis.limit).map(r => r.data()));
                        
                        console.log(`  âœ… æ‰¾åˆ° ${data.length} ç¯‡`);
                        
                        data.forEach(page => {
                            const normUrl = normalizeUrl(page.url);
                            if (!isCurrentPage(page.url) && !allCandidates.has(normUrl)) {
                                allCandidates.set(normUrl, page);
                            } else if (isCurrentPage(page.url)) {
                                console.log(`ğŸš« æ—©æœŸæ’é™¤è‡ªå·± (${axis.name}): ${page.meta.title} (${page.url})`);
                            }
                        });
                    } catch (err) {
                        console.error(`  âŒ ${axis.name} æœå°‹å¤±æ•—:`, err);
                    }
                }
            }
            
            console.log(`\nâœ… åˆä½µå¾Œå…±æœ‰ ${allCandidates.size} ç¯‡å€™é¸æ–‡ç« `);
            
            if (allCandidates.size > 0) {
                const candidateArray = Array.from(allCandidates.values());
                
                // ğŸ¯ è¨ˆç®—æ¯ç¯‡æ–‡ç« çš„æ¬Šé‡
                const weighted = candidateArray.map((page, index) => {
                    // åŸºç¤æ¬Šé‡: å¾æœå°‹çµæœé †åºæ±ºå®š
                    let weight = Math.max(5, 20 - index); // æœ€ä½æ¬Šé‡ 5
                    let boostReason = [];
                    
                    const pageContent = JSON.stringify(page).toLowerCase();
                    
                    // æ–¹æ³• 1: æª¢æŸ¥æ˜¯å¦æœ‰å…±åŒçš„è»¸æ¨™ç±¤
                    const checkAxis = (axisTags, axisName) => {
                        if (axisTags.length > 0) {
                            const hasMatch = axisTags.some(tag => {
                                const tagLower = tag.toLowerCase();
                                return pageContent.includes(tagLower);
                            });
                            if (hasMatch) {
                                boostReason.push(`åŒ ${axisName}`);
                                return true;
                            }
                        }
                        return false;
                    };
                    
                    const hasCommonAxis = 
                        checkAxis(categories, 'category') ||
                        checkAxis(tags, 'tag') ||
                        checkAxis(projects, 'project') ||
                        checkAxis(clubhouse, 'clubhouse') ||
                        checkAxis(series, 'series') ||
                        checkAxis(topics, 'topics') ||
                        checkAxis(highlights, 'highlights');
                    
                    // æ–¹æ³• 2: æª¢æŸ¥ AI Keywords ç›¸ä¼¼åº¦
                    let pageKeywords = [];
                    try {
                        const filtersStr = JSON.stringify(page.filters || {});
                        const metaStr = JSON.stringify(page.meta || {});
                        const combinedStr = filtersStr + metaStr;
                        
                        // å˜—è©¦åŒ¹é… JSON é™£åˆ—æ ¼å¼çš„ keywords
                        const keywordMatch = combinedStr.match(/\["[^"]+(?:","[^"]+)*"\]/g);
                        if (keywordMatch) {
                            try {
                                pageKeywords = JSON.parse(keywordMatch[0]);
                            } catch (e) {}
                        }
                    } catch (e) {}
                    
                    // è¨ˆç®— AI Keywords é‡ç–Šæ•¸é‡
                    let keywordOverlap = 0;
                    if (ai_kw.length > 0 && pageKeywords.length > 0) {
                        const currentKeywords = ai_kw.map(k => k.toLowerCase());
                        keywordOverlap = pageKeywords.filter(pk => 
                            currentKeywords.some(ck => 
                                ck.includes(pk.toLowerCase()) || pk.toLowerCase().includes(ck)
                            )
                        ).length;
                        
                        if (keywordOverlap >= 2) {
                            boostReason.push(`${keywordOverlap}å€‹å…±åŒé—œéµå­—`);
                            weight *= 1.5;
                        } else if (keywordOverlap === 1) {
                            boostReason.push(`1å€‹å…±åŒé—œéµå­—`);
                            weight *= 1.2;
                        }
                    }
                    
                    // åŒè»¸æ–‡ç« æ¬Šé‡åŠ å€
                    if (hasCommonAxis) {
                        weight *= 2;
                    }
                    
                    // é¡¯ç¤ºåŠ æˆåŸå› 
                    if (boostReason.length > 0) {
                        console.log(`    ğŸ”– ${page.meta.title.substring(0, 35)}... (æ¬Šé‡ ${weight.toFixed(1)}: ${boostReason.join(', ')})`);
                    }
                    
                    return { page, weight };
                });
                
                // âš ï¸ é‡è¦:ç«‹å³éæ¿¾æ‰ç•¶å‰æ–‡ç« ,é¿å…å®ƒå‡ºç¾åœ¨ä»»ä½•åœ°æ–¹
                const filteredWeighted = weighted.filter(item => {
                    const itemUrl = normalizeUrl(item.page.url);
                    const isSelf = isCurrentPage(item.page.url);
                    if (isSelf) {
                        console.log(`\n  âš ï¸ æ’é™¤è‡ªå·±: ${item.page.meta.title.substring(0, 40)}...`);
                    }
                    return !isSelf;
                });
                
                console.log(`  âœ… æ’é™¤å¾Œå‰© ${filteredWeighted.length} ç¯‡å€™é¸`);
                
                console.log("\n  ğŸ“Š æ¬Šé‡åˆ†ä½ˆ (å‰ 10 å):");
                filteredWeighted
                    .sort((a, b) => b.weight - a.weight)
                    .slice(0, 10)
                    .forEach((item, i) => {
                        console.log(`    ${i + 1}. æ¬Šé‡ ${item.weight.toFixed(1)}: ${item.page.meta.title.substring(0, 40)}...`);
                    });
                
                // ğŸ² é¸æ“‡æ¨è–¦æ–‡ç« :ç¬¬ 1 ç¯‡é¸æœ€é«˜æ¬Šé‡,ç¬¬ 2-3 ç¯‡åŠ æ¬Šéš¨æ©Ÿ
                
                // ğŸ² é¸æ“‡æ¨è–¦æ–‡ç« :ç¬¬ 1 ç¯‡é¸æœ€é«˜æ¬Šé‡,ç¬¬ 2-3 ç¯‡åŠ æ¬Šéš¨æ©Ÿ
                const selectRecommendations = (items, count, seed) => {
                    if (items.length === 0) {
                        console.log("  âš ï¸ æ²’æœ‰å¯æ¨è–¦çš„æ–‡ç« ");
                        return [];
                    }
                    
                    const selected = [];
                    const remaining = [...items];
                    
                    // ç¬¬ 1 ç¯‡:é¸æ¬Šé‡æœ€é«˜çš„(items å·²ç¶“æ’é™¤è‡ªå·±äº†)
                    remaining.sort((a, b) => b.weight - a.weight);
                    selected.push(remaining[0].page);
                    remaining.splice(0, 1);
                    
                    console.log(`  ğŸ† ç¬¬ 1 ç¯‡(æœ€é«˜æ¬Šé‡): ${selected[0].meta.title.substring(0, 40)}...`);
                    
                    // ç¬¬ 2-3 ç¯‡:åŠ æ¬Šéš¨æ©Ÿé¸æ“‡
                    if (remaining.length > 0) {
                        // ç°¡å–®çš„å½éš¨æ©Ÿç”Ÿæˆå™¨
                        let currentSeed = seed;
                        const random = () => {
                            currentSeed = (currentSeed * 9301 + 49297) % 233280;
                            return currentSeed / 233280;
                        };
                        
                        const remainingCount = Math.min(count - 1, remaining.length);
                        
                        for (let i = 0; i < remainingCount; i++) {
                            // è¨ˆç®—ç¸½æ¬Šé‡
                            const totalWeight = remaining.reduce((sum, item) => sum + item.weight, 0);
                            
                            // éš¨æ©Ÿé¸ä¸€å€‹æ•¸å­—
                            let rand = random() * totalWeight;
                            
                            // æ‰¾åˆ°å°æ‡‰çš„é …ç›®
                            let selectedIndex = 0;
                            for (let j = 0; j < remaining.length; j++) {
                                rand -= remaining[j].weight;
                                if (rand <= 0) {
                                    selectedIndex = j;
                                    break;
                                }
                            }
                            
                            // é¸ä¸­ä¸¦ç§»é™¤
                            selected.push(remaining[selectedIndex].page);
                            console.log(`  ğŸ² ç¬¬ ${selected.length} ç¯‡(åŠ æ¬Šéš¨æ©Ÿ): ${remaining[selectedIndex].page.meta.title.substring(0, 40)}...`);
                            remaining.splice(selectedIndex, 1);
                        }
                    }
                    
                    return selected;
                };
                
                results = selectRecommendations(filteredWeighted, 3, seed);
                
                console.log(`\n  âœ… é¸å‡º ${results.length} ç¯‡æ¨è–¦ (ç¬¬1ç¯‡=æœ€é«˜æ¬Šé‡, ç¬¬2-3ç¯‡=åŠ æ¬Šéš¨æ©Ÿ)`);
            }
            
            // ğŸ“ ä¿åº•æ©Ÿåˆ¶:å¦‚æœçµæœä¸è¶³
            if (results.length < 3) {
                console.log("\nğŸ“ ä¿åº•æ©Ÿåˆ¶:è£œå……æ–‡ç« ");
                try {
                    const allSite = await window.pagefind.search("");
                    const fallback = await Promise.all(allSite.results.slice(0, 30).map(r => r.data()));
                    
                    // éæ¿¾æ‰ç•¶å‰æ–‡ç« å’Œå·²æ¨è–¦çš„
                    const existingUrls = new Set(results.map(r => normalizeUrl(r.url)));
                    const filtered = fallback.filter(page => {
                        const pageUrl = normalizeUrl(page.url);
                        return !isCurrentPage(page.url) && !existingUrls.has(pageUrl);
                    });
                    
                    // ç°¡å–®éš¨æ©Ÿ(ç”¨ç¨®å­)
                    let currentSeed = seed;
                    const random = () => {
                        currentSeed = (currentSeed * 9301 + 49297) % 233280;
                        return currentSeed / 233280;
                    };
                    
                    const shuffled = filtered.sort(() => random() - 0.5);
                    
                    const needed = 3 - results.length;
                    const toAdd = shuffled.slice(0, needed);
                    results.push(...toAdd);
                    
                    console.log(`  âœ… è£œå…… ${toAdd.length} ç¯‡`);
                } catch (err) {
                    console.error("  âŒ ä¿åº•æ©Ÿåˆ¶å¤±æ•—:", err);
                }
            }
  
            // æœ€çµ‚é˜²å‘†ï¼šçµ•å°ä¸æ¸²æŸ“è‡ªå·±
            results = results.filter(page => {
                if (isCurrentPage(page.url)) {
                    console.warn(`æœ€çµ‚éšæ®µä»ç™¼ç¾è‡ªå·±ï¼Œå·²ç§»é™¤: ${page.meta.title}`);
                    return false;
                }
                return true;
            });

            console.log("\nâœ… æœ€çµ‚æ¨è–¦:");
            results.forEach((r, i) => {
                console.log(`  ${i + 1}. ${r.meta.title.substring(0, 40)}...`);
            });
  
            // æ¸…ç†æ¨™é¡Œ
            const cleanTitle = (title) => {
                if (!title) return '';

                let cleaned = title;

                // å®šç¾©è¦ç§»é™¤çš„å¾Œç¶´æ¨¡å¼(å¯æ“´å……)
                const sitePatterns = [
                    /[\sï½œ\|\-â€“â€”]*è†è½çš„æ²³æµ(?:ï½œé–±è®€ãƒ»æ›¸å¯«ãƒ»å¿ƒç†ãƒ»é›»å½±)?\s*$/i,
                    /[\sï½œ\|\-â€“â€”]*é–±è®€ãƒ»æ›¸å¯«ãƒ»å¿ƒç†ãƒ»é›»å½±\s*$/i,
                    /[\sï½œ\|\-â€“â€”]*è†è½çš„æ²³æµ\s*$/i
                ];

                // ç§»é™¤å¾Œç¶´
                for (const pattern of sitePatterns) {
                    cleaned = cleaned.replace(pattern, '').trim();
                }

                // å¦‚æœé‚„æœ‰æ®˜é¤˜çš„åˆ†éš”ç¬¦åœ¨çµå°¾,ä¹Ÿæ¸…æ‰
                cleaned = cleaned.replace(/[\sï½œ\|\-â€“â€”,:,ï¼›]+$/, '').trim();

                return cleaned;
            };
  
            // æ¸²æŸ“
            if (results.length > 0) {
                results.forEach(page => {
                    const card = document.createElement('a');
                    card.href = page.url;
                    card.style.cssText = `
                        display: block;
                        padding: 10px 12px;
                        background: #fff;
                        border: 1px solid #e8e8e8;
                        border-radius: 6px;
                        text-decoration: none;
                        color: #444;
                        font-size: 0.85rem;
                        line-height: 1.4;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
                        transition: all 0.2s ease;
                    `;
                    card.onmouseenter = () => {
                        card.style.transform = "translateY(-2px)";
                        card.style.boxShadow = "0 3px 8px rgba(0,0,0,0.1)";
                        card.style.borderColor = "#d0d0d0";
                    };
                    card.onmouseleave = () => {
                        card.style.transform = "translateY(0)";
                        card.style.boxShadow = "0 1px 3px rgba(0,0,0,0.05)";
                        card.style.borderColor = "#e8e8e8";
                    };
                    
                    const cleanedTitle = cleanTitle(page.meta.title);
                    card.innerHTML = `<strong style="font-weight: 500;">${cleanedTitle}</strong>`;
                    list.appendChild(card);
                });
                section.style.display = 'block';
            }
        } catch (e) { 
            console.error("âŒ Pagefind éŒ¯èª¤:", e);
        }
    });
  </script>